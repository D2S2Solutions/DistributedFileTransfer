/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.d2s2.ui;

/**
 * @author Heshan Sandamal
 */

import com.d2s2.constants.ApplicationConstants;
import com.d2s2.models.Node;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

public class FileSearchInterface extends javax.swing.JFrame {


    private DefaultTableModel dtmForSearchResultTable;
    private DefaultTableModel dtmForSelfFileTable;
    private DefaultTableModel dtmForPeerTable;
    private DefaultTableModel dtmForstatTable;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField ipTextField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField portTextField;
    private javax.swing.JButton registerButton;
    private javax.swing.JButton searchButton;
    private javax.swing.JTable searchResultsTable;
    private javax.swing.JTextField searchTextField;
    private javax.swing.JTable selfFilesTable;
    private javax.swing.JButton unregisterButton;
    private javax.swing.JTextField userNameTextField;

    public FileSearchInterface(GUIController guiController, ArrayList<String> fileList) {
        initComponents();
        this.selfFilesTable.getTableHeader().setVisible(false);
        this.userNameTextField.setText(ApplicationConstants.USER_NAME);
        this.ipTextField.setText(ApplicationConstants.IP);
        this.portTextField.setText(String.valueOf(ApplicationConstants.PORT));
        this.unregisterButton.setEnabled(false);
        this.searchTextField.addActionListener(new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent evt) {
                dtmForSearchResultTable.setRowCount(0);
                try {
                    guiController.searchFile(searchTextField.getText());
                } catch (RemoteException e) {
                    e.printStackTrace();
                } catch (NotBoundException e) {
                    e.printStackTrace();
                }

            }
        });

        this.searchButton.addActionListener(evt -> {
            dtmForSearchResultTable.setRowCount(0);
            try {
                guiController.searchFile(this.searchTextField.getText());
            } catch (RemoteException | NotBoundException e) {
                e.printStackTrace();
            }
        });

        this.registerButton.addActionListener(evt -> {
            try {
                guiController.registerInBS();
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        this.unregisterButton.addActionListener(evt -> {
            try {
                guiController.unRegister();
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        });

        dtmForSearchResultTable = (DefaultTableModel) searchResultsTable.getModel();
        dtmForSearchResultTable.setRowCount(0);

        dtmForSelfFileTable = (DefaultTableModel) selfFilesTable.getModel();

        dtmForPeerTable = (DefaultTableModel) peerTable.getModel();
        dtmForPeerTable.setRowCount(0);

        dtmForstatTable = (DefaultTableModel) statTable.getModel();
        dtmForstatTable.setRowCount(0);

        for (int x = 0; x < fileList.size(); x++) {
            dtmForSelfFileTable.setValueAt(fileList.get(x).replace("@", " ").toString(), 0, x);
        }
    }

    public synchronized void addToTable(String nodeIp, int port, int fileCount, HashSet<String> fileList, int ttl) {
        System.out.println("Calling interface " + nodeIp + port);
        StringBuilder fileNames = new StringBuilder();
        for (String fileName : fileList) {
            fileNames.append(fileName.replace("@", " ")).append(" , ");
        }
        fileNames.delete(fileNames.length()-2,fileNames.length()-1);
        int noOfHops = ApplicationConstants.HOPS - 1 - ttl;
        if (!this.isValueExistsAtTable(nodeIp, port)) {
            this.dtmForSearchResultTable.addRow(new Object[]{nodeIp, port, fileCount, fileNames.toString(), noOfHops});
        }
    }

    private boolean isValueExistsAtTable(String ip, int port) {
        int rowCount = this.dtmForSearchResultTable.getRowCount();
        for (int i = 0; i < rowCount; i++) {
            String nodeIp = String.valueOf(dtmForSearchResultTable.getValueAt(i, 0));
            int nodePort = Integer.parseInt(dtmForSearchResultTable.getValueAt(i, 1).toString());

            if (nodeIp.equals(ip) && nodePort == port) {
                return true;
            }
        }
        return false;
    }

    public void showMessage(String message) {
        JOptionPane.showMessageDialog(this, message);
    }

    public String showInputDialog(String message) {
        return JOptionPane.showInputDialog(this, message);
    }
    // End of variables declaration//GEN-END:variables


    public void populatePeerTable(Set<Node> peerList) {
        dtmForPeerTable.setRowCount(0);
        final Iterator<Node> iterator = peerList.iterator();
        while(iterator.hasNext()) {
            Node node = iterator.next();
            dtmForPeerTable.addRow(new Object[]{node.getNodeIp(), node.getPort()});
        }
    }

    public void populateStatTable(ConcurrentHashMap<String, ConcurrentLinkedQueue<Node>> statTable){
        dtmForstatTable.setRowCount(0);
        Enumeration<String> keys = statTable.keys();
        while(keys.hasMoreElements()){
            String fileName = keys.nextElement();
            final ConcurrentLinkedQueue<Node> concurrentLinkedQueue = statTable.get(fileName);
            String nodesList="";
            for (Node node:concurrentLinkedQueue) {
                nodesList += node.getNodeIp()+ ":" +node.getPort() + " , ";
            }
            dtmForstatTable.addRow(new Object[]{fileName.replace("@", " "),nodesList});
        }

    }
    public void handleRegistration(){
        registerButton.setEnabled(false);
        unregisterButton.setEnabled(true);
    }
    public void handleUnRegistration(){
        registerButton.setEnabled(true);
        unregisterButton.setEnabled(false);
    }